{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "packed-form",
  "type": "registry:component",
  "title": "Packed Form",
  "description": "A form component that handles automatically validation and styling",
  "registryDependencies": [
    "button",
    "form",
    "input",
    "textarea"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/packed-form/form.tsx",
      "content": "import { useMemo } from \"react\";\r\nimport { getFieldValidator, getFields } from \"./utils/validation\";\r\nimport { FormDefinition } from \"./types/form\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Form as ShadCnForm, FormField } from \"@/components/ui/form\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport z from \"zod\";\r\n\r\ninterface FormProps {\r\n  formDefinition: FormDefinition;\r\n}\r\n\r\nexport const Form = ({ formDefinition }: FormProps) => {\r\n  const fields = useMemo(() => getFields(formDefinition), [formDefinition]);\r\n  const formSchema = useMemo(() => getFieldValidator(fields), [fields]);\r\n\r\n  const defaultValues = useMemo(() => {\r\n    return Object.keys(fields).reduce((acc, key) => {\r\n      acc[key] = \"\";\r\n      return acc;\r\n    }, {} as Record<string, string>);\r\n  }, [fields]);\r\n\r\n  const form = useForm<z.infer<typeof formSchema>>({\r\n    resolver: zodResolver(formSchema),\r\n    defaultValues,\r\n  });\r\n\r\n  const onSubmit = (data: z.infer<typeof formSchema>) => {\r\n    console.log(\"Form Data:\", data);\r\n    alert(\"Form submitted! Check console for data.\");\r\n  };\r\n\r\n  return (\r\n    <ShadCnForm {...form}>\r\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\r\n        {Object.entries(fields).map(([fieldName, field]) => (\r\n          <FormField\r\n            control={form.control}\r\n            name={fieldName}\r\n            key={fieldName}\r\n            render={(p) => field.render(p)}\r\n          />\r\n        ))}\r\n\r\n        <Button type=\"submit\">Submit</Button>\r\n      </form>\r\n    </ShadCnForm>\r\n  );\r\n};\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/base.tsx",
      "content": "import { z } from \"zod\";\r\nimport React from \"react\";\r\nimport type { BaseFieldDefinition } from \"../types/base\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\nexport class BaseField<T extends BaseFieldDefinition = BaseFieldDefinition> {\r\n  constructor(public definition: T) {}\r\n\r\n  getValidator(): z.ZodType {\r\n    throw new Error(\"Method not implemented.\");\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  render(_: { field: ControllerRenderProps }): React.ReactElement {\r\n    throw new Error(\"Method not implemented.\");\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/email.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface EmailOptions {\r\n  minLength?: number;\r\n  maxLength?: number;\r\n}\r\n\r\nexport interface EmailFieldDefinition extends BaseFieldDefinition {\r\n  type: \"email\";\r\n  options?: EmailOptions;\r\n}\r\n\r\nexport class EmailField extends BaseField<EmailFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.string().email();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.minLength !== undefined) {\r\n        validator = validator.min(options.minLength);\r\n      }\r\n\r\n      if (options.maxLength !== undefined) {\r\n        validator = validator.max(options.maxLength);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Input {...field} type=\"text\" />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/float.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface FloatOptions {\r\n  min?: number;\r\n  max?: number;\r\n}\r\n\r\nexport interface FloatFieldDefinition extends BaseFieldDefinition {\r\n  type: \"float\";\r\n  options?: FloatOptions;\r\n}\r\n\r\nexport class FloatField extends BaseField<FloatFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.coerce.number();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.min !== undefined) {\r\n        validator = validator.min(options.min);\r\n      }\r\n\r\n      if (options.max !== undefined) {\r\n        validator = validator.max(options.max);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Input {...field} type=\"number\" />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/int.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface IntOptions {\r\n  min?: number;\r\n  max?: number;\r\n}\r\n\r\nexport interface IntFieldDefinition extends BaseFieldDefinition {\r\n  type: \"int\";\r\n  options?: IntOptions;\r\n}\r\n\r\nexport class IntField extends BaseField<IntFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.coerce.number().int();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.min !== undefined) {\r\n        validator = validator.min(options.min);\r\n      }\r\n\r\n      if (options.max !== undefined) {\r\n        validator = validator.max(options.max);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Input {...field} type=\"number\" />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/password.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface PasswordOptions {\r\n  minLength?: number;\r\n  maxLength?: number;\r\n}\r\n\r\nexport interface PasswordFieldDefinition extends BaseFieldDefinition {\r\n  type: \"password\";\r\n  options?: PasswordOptions;\r\n}\r\n\r\nexport class PasswordField extends BaseField<PasswordFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.string();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.minLength !== undefined) {\r\n        validator = validator.min(options.minLength);\r\n      }\r\n\r\n      if (options.maxLength !== undefined) {\r\n        validator = validator.max(options.maxLength);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Input {...field} type=\"password\" />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/string.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface StringOptions {\r\n  minLength?: number;\r\n  maxLength?: number;\r\n}\r\n\r\nexport interface StringFieldDefinition extends BaseFieldDefinition {\r\n  type: \"string\";\r\n  options?: StringOptions;\r\n}\r\n\r\nexport class StringField extends BaseField<StringFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.string();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.minLength !== undefined) {\r\n        validator = validator.min(options.minLength);\r\n      }\r\n\r\n      if (options.maxLength !== undefined) {\r\n        validator = validator.max(options.maxLength);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Input {...field} type=\"text\" />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/fields/text.tsx",
      "content": "import { z } from \"zod\";\r\nimport { BaseFieldDefinition } from \"../types/base\";\r\nimport { BaseField } from \"./base\";\r\nimport {\r\n  FormControl,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from \"@/components/ui/form\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { ControllerRenderProps } from \"react-hook-form\";\r\n\r\ninterface TextOptions {\r\n  minLength?: number;\r\n  maxLength?: number;\r\n}\r\n\r\nexport interface TextFieldDefinition extends BaseFieldDefinition {\r\n  type: \"text\";\r\n  options?: TextOptions;\r\n}\r\n\r\nexport class TextField extends BaseField<TextFieldDefinition> {\r\n  getValidator() {\r\n    let validator = z.string();\r\n\r\n    const { options, optional } = this.definition;\r\n\r\n    if (options) {\r\n      if (options.minLength !== undefined) {\r\n        validator = validator.min(options.minLength);\r\n      }\r\n\r\n      if (options.maxLength !== undefined) {\r\n        validator = validator.max(options.maxLength);\r\n      }\r\n    }\r\n\r\n    if (optional) {\r\n      return z.optional(validator);\r\n    } else {\r\n      return validator;\r\n    }\r\n  }\r\n\r\n  render({ field }: { field: ControllerRenderProps }) {\r\n    return (\r\n      <FormItem>\r\n        <FormLabel>{this.definition.label}</FormLabel>\r\n        <FormControl>\r\n          <Textarea {...field} />\r\n        </FormControl>\r\n        <FormMessage />\r\n      </FormItem>\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/types/base.ts",
      "content": "export type FieldType =\r\n  | \"email\"\r\n  | \"float\"\r\n  | \"int\"\r\n  | \"password\"\r\n  | \"string\"\r\n  | \"text\";\r\n\r\nexport interface BaseFieldDefinition {\r\n  type: FieldType;\r\n  label: string;\r\n  optional?: boolean;\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/types/form.ts",
      "content": "import { EmailFieldDefinition } from \"../fields/email\";\r\nimport { FloatFieldDefinition } from \"../fields/float\";\r\nimport { IntFieldDefinition } from \"../fields/int\";\r\nimport { PasswordFieldDefinition } from \"../fields/password\";\r\nimport { StringFieldDefinition } from \"../fields/string\";\r\nimport { TextFieldDefinition } from \"../fields/text\";\r\n\r\nexport type FieldDefinition = \r\n  | EmailFieldDefinition\r\n  | FloatFieldDefinition\r\n  | IntFieldDefinition\r\n  | PasswordFieldDefinition\r\n  | StringFieldDefinition\r\n  | TextFieldDefinition;\r\n\r\nexport type FormDefinition = Record<string, FieldDefinition>;\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/packed-form/utils/validation.ts",
      "content": "import { z } from \"zod\";\r\nimport { FieldDefinition, FormDefinition } from \"../types/form\";\r\nimport { FieldType } from \"../types/base\";\r\nimport { BaseField } from \"../fields/base\";\r\nimport { EmailField } from \"../fields/email\";\r\nimport { FloatField } from \"../fields/float\";\r\nimport { IntField } from \"../fields/int\";\r\nimport { PasswordField } from \"../fields/password\";\r\nimport { StringField } from \"../fields/string\";\r\nimport { TextField } from \"../fields/text\";\r\n\r\n// TODO: type-safe mapping\r\nconst fieldsMap: Record<FieldType, any> = {\r\n  email: EmailField,\r\n  float: FloatField,\r\n  int: IntField,\r\n  password: PasswordField,\r\n  string: StringField,\r\n  text: TextField,\r\n} as const;\r\n\r\nexport function getField(fieldDefinition: FieldDefinition): BaseField {\r\n  const FieldClass = fieldsMap[fieldDefinition.type];\r\n\r\n  if (!FieldClass) {\r\n    throw new Error(`Unsupported field type: ${fieldDefinition.type}`);\r\n  }\r\n\r\n  return new FieldClass(fieldDefinition);\r\n}\r\n\r\nexport function getFields(\r\n  formDefinition: FormDefinition\r\n): Record<string, BaseField> {\r\n  return Object.entries(formDefinition).reduce(\r\n    (acc, [fieldName, fieldDefinition]) => {\r\n      acc[fieldName] = getField(fieldDefinition);\r\n      return acc;\r\n    },\r\n    {} as Record<string, BaseField>\r\n  );\r\n}\r\n\r\nexport function getFieldValidator(fields: Record<string, BaseField>) {\r\n  const shape = Object.entries(fields).reduce(\r\n    (acc, [fieldName, field]) => {\r\n      acc[fieldName] = field.getValidator();\r\n      return acc;\r\n    },\r\n    {} as Record<string, z.ZodType>\r\n  );\r\n\r\n  return z.object(shape);\r\n}\r\n",
      "type": "registry:lib"
    }
  ]
}